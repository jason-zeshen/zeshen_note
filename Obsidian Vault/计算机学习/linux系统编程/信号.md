

## 信号共性：
- 简单
- 不能携带大量信息
- 满足条件才发生

## 信号的特质：
- 信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置必须立即停止运行处理信号，处理结束再执行后续指令。
* 所有信号的产生以及处理全部是由 __内核__ 完成。

## 信号相关概念：
信号产生：
1. 按键产生，如：ctrl + c
2. 系统调用产生。程序中使用系统调用函数，如：kill、raise、abort
3. 软件条件产生，如：定时器 alarm
4. 硬件异常产生，如：非法访问内存（段错误）、除0（浮点数除外）、内存对齐错误（总线错误）
5. 命令产生， 如：kill命令

信号状态相关：
- 递达：递送并且到达进程。
- 未决：产生和递达之间的状态，主要由于阻塞（屏蔽）导致该状态
- 阻塞信号集（信号屏蔽字）：本质是位图。用来记录信号的屏蔽状态。一个被屏蔽的信号在解除屏蔽前，一直处于未决态。
- 未决信号集：本质是位图。用来记录信号的处理状态。未决为1，表示信号已产生但是未被处理。

信号处理方式：
1. 执行默认动作
2. 忽略（丢弃）
3. 捕捉（调用用户处理函数）

## 信号四要素：
四要素：
- 编号
- 名称
- 对应时间
- 默认处理动作：
	- Term：终止进程
	- Ign： 忽略信号 (默认即时对该种信号忽略操作)
	- Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)
	- Stop：停止（暂停）进程
	- Cont：继续运行进程


查看信号：
	命令：kill -l
	man 7 signal

64个信号
不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。

- 9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。
- 18) SIGCONT 唯一默认动作为忽略的信号

## 信号集操作

- 未决信号集
- 阻塞信号集（信号屏蔽字 mask）
- 自定义信号集 mask

![](/images/信号集操作.png)

### 信号集操作函数：
- sigset_t set; 自定义信号集。
- sigemptyset(sigset_t set); 晴空信号集。
- sigefillset(sigset_t set); 全部置1.
- sigaddset(sigset_t set); 将一个信号添加到信号集中。
- sigdelset(sigset_t set); 将一个信号从信号集中删除。
- sigismember(const sigset_t set, int signum); 判断一个信号是否在信号集中。
	- 1: 在
	- 0: 不在



### 设置信号屏蔽字和解除屏蔽
- int sigprocmask(int how, const sigset_t \*set, sigset_t \*oldset );
	- 入参：
		- how：
			- SIG_BLOCK: 设置阻塞。mask = mask ｜ set
			- SIG_UNBLOCK: 解除阻塞。 mask = mask & ~set
			- SIG_SETMASK: 用自定义set替换mask。mask = set
		- set: 自定义set。
		- oldset：旧有的mask。
	- 返回值
		- 0: 成功
		- -1: 失败

### 查看未决信号集
- int sigpending(sigset_t \*set);
	- 传出参数：
		- set 未决信号集

练习：编写程序。把所有常规信号的未决状态打印至屏幕。							【sigpending.c】
																					                       【sigsfunc.c】

